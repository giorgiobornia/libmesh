dnl ----------------------------------------------------------------
dnl Tests for various C++11 features.  These will probably only work
dnl if they are run after the autoconf test that sets -std=c++11.
dnl ----------------------------------------------------------------

AC_DEFUN([LIBMESH_TEST_CXX11_MOVE],
  [
    have_cxx11_move=no

    # Only run the test if enablecxx11==yes
    if (test "x$enablecxx11" = "xyes"); then
      AC_MSG_CHECKING(for C++11 std::move support)
      AC_LANG_PUSH([C++])

      AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
      @%:@include <utility>
      template <class T>
      void move_swap(T& a, T& b)
      {
        T tmp(std::move(a));
        a = std::move(b);
        b = std::move(tmp);
      }
      ]], [[
          int one = 1, two = 2;
          move_swap(one,two);
      ]])],[
          AC_MSG_RESULT(yes)
          AC_DEFINE(HAVE_CXX11_MOVE, 1, [Flag indicating whether compiler supports std::move])
          have_cxx11_move=yes
      ],[
          AC_MSG_RESULT(no)
      ])

      AC_LANG_POP([C++])
    fi

    AM_CONDITIONAL(HAVE_CXX11_MOVE, test x$have_cxx11_move == xyes)
  ])


AC_DEFUN([LIBMESH_TEST_CXX11_SHARED_PTR],
  [
    have_cxx11_shared_ptr=init

    # Only run the test if enablecxx11==yes
    if (test "x$enablecxx11" = "xyes"); then
      AC_LANG_PUSH([C++])

      # Save any original value that CXXFLAGS had
      saveCXXFLAGS="$CXXFLAGS"

      # Try compiling the test code in all methods requested by the user
      for method in ${METHODS}; do
          case "${method}" in
              optimized|opt)
                CXXFLAGS="$saveCXXFLAGS $CXXFLAGS_OPT $CPPFLAGS_OPT";;

              debug|dbg)
                CXXFLAGS="$saveCXXFLAGS $CXXFLAGS_DBG $CPPFLAGS_DBG";;

              devel)
                CXXFLAGS="$saveCXXFLAGS $CXXFLAGS_DEVEL $CPPFLAGS_DEVEL";;

              profiling|pro|prof)
                CXXFLAGS="$saveCXXFLAGS $CXXFLAGS_PROF $CPPFLAGS_PROF";;

              oprofile|oprof)
                CXXFLAGS="$saveCXXFLAGS $CXXFLAGS_OPROF $CPPFLAGS_OPROF";;

              *)
              AC_MSG_ERROR([bad value ${method} for --with-methods])
              ;;
          esac

          # If compilation fails for *any* of the methods, we'll disable
          # shared_ptr support for *all* methods.
          if test "x$have_cxx11_shared_ptr" != xno; then
            AC_MSG_CHECKING([for C++11 std::shared_ptr support with ${method} flags])

            AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
            @%:@include <memory>
            ]], [[
                std::shared_ptr<int> p1;
                std::shared_ptr<int> p2 (new int);
                std::shared_ptr<int> p3 (p2);
                p3.reset(new int);
            ]])],[
                have_cxx11_shared_ptr=yes
                AC_MSG_RESULT(yes)
            ],[
                have_cxx11_shared_ptr=no
                AC_MSG_RESULT(no)
            ])

          fi
      done

      # Only set the header file variable if our flag was set to 'yes'.
      if test "x$have_cxx11_shared_ptr" = xyes; then
        AC_DEFINE(HAVE_CXX11_SHARED_PTR, 1, [Flag indicating whether compiler supports std::shared_ptr])
      fi

      # Restore the original flags, whatever they were.
      CXXFLAGS="$saveCXXFLAGS"
      AC_LANG_POP([C++])
    fi

    AM_CONDITIONAL(HAVE_CXX11_SHARED_PTR, test x$have_cxx11_shared_ptr == xyes)
  ])


AC_DEFUN([LIBMESH_TEST_CXX11_UNIQUE_PTR],
  [
    have_cxx11_unique_ptr=no

    # Only run the test if enablecxx11==yes
    if (test "x$enablecxx11" = "xyes"); then
      AC_MSG_CHECKING(for C++11 std::unique_ptr support)
      AC_LANG_PUSH([C++])


      AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
      @%:@include <iostream>
      @%:@include <memory>
      struct Foo
      {
        Foo()      { std::cout << "Foo::Foo\n";  }
        ~Foo()     { std::cout << "Foo::~Foo\n"; }
      };
          ]], [[
      {
        // up now owns a Foo
        std::unique_ptr<Foo> up(new Foo);
      } // Foo deleted when up goes out of scope
      ]])],[
        AC_MSG_RESULT(yes)
        AC_DEFINE(HAVE_CXX11_UNIQUE_PTR, 1, [Flag indicating whether compiler supports std::unique_ptr])
        have_cxx11_unique_ptr=yes
      ],[
        AC_MSG_RESULT(no)
      ])

      AC_LANG_POP([C++])
    fi

    AM_CONDITIONAL(HAVE_CXX11_UNIQUE_PTR, test x$have_cxx11_unique_ptr == xyes)
  ])




AC_DEFUN([LIBMESH_TEST_CXX11_REGEX],
  [
    have_cxx11_regex=no

    # Only run the test if enablecxx11==yes
    if (test "x$enablecxx11" = "xyes"); then
      AC_MSG_CHECKING(for C++11 std::regex support)
      AC_LANG_PUSH([C++])

      dnl We actually have to try and *run* the test program, since
      dnl GCC up to 4.8 will compile this but then is not able to run it.
      dnl GCC 4.9.1 and Clang 3.5 are actually able to run this test code.
      dnl
      dnl Note the quadruple backslash below -- this is needed so it
      dnl expands to 2 backslashes in the test program generated by
      dnl Autoconf...
      AC_RUN_IFELSE([AC_LANG_PROGRAM([[
      @%:@include <regex>
      ]], [[
        std::regex integer_regex("(\\\\+|-)?[[:digit:]]+");
        regex_match("abc", integer_regex);
        regex_match("123", integer_regex);
      ]])],[
        AC_MSG_RESULT(yes)
        AC_DEFINE(HAVE_CXX11_REGEX, 1, [Flag indicating whether compiler supports std::regex])
        have_cxx11_regex=yes
      ],[
        AC_MSG_RESULT(no)
      ],[
        dnl The test program is not run when cross-compiling, so you are supposed to
        dnl provide a "pessimistic" action here.  We'll just assume the compiler does
        dnl not support C++11 regexes in this case.
        AC_MSG_RESULT(no)
      ])

      AC_LANG_POP([C++])
    fi

    AM_CONDITIONAL(HAVE_CXX11_REGEX, test x$have_cxx11_regex == xyes)
  ])


AC_DEFUN([LIBMESH_TEST_CXX11_OVERRIDE],
  [
    have_cxx11_override=no

    # Only run the test if enablecxx11==yes
    if (test "x$enablecxx11" = "xyes"); then
      AC_MSG_CHECKING(for C++11 override keyword support)
      AC_LANG_PUSH([C++])

      AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
      ]], [[
        struct Base {
        virtual void f() {}
        };
        struct Child : public Base {
        virtual void f() override {}
        };
      ]])],[
        AC_MSG_RESULT(yes)
        AC_DEFINE(HAVE_CXX11_OVERRIDE, 1, [Flag indicating whether compiler supports the override keyword])
        have_cxx11_override=yes
      ],[
        AC_MSG_RESULT(no)
      ])

      AC_LANG_POP([C++])
    fi

    AM_CONDITIONAL(HAVE_CXX11_OVERRIDE, test x$have_cxx11_override == xyes)
  ])



AC_DEFUN([LIBMESH_TEST_CXX11_INITIALIZER_LIST],
  [
    have_cxx11_initializer_list=no

    # Only run the test if enablecxx11==yes
    if (test "x$enablecxx11" = "xyes"); then
      AC_MSG_CHECKING(for C++11 initializer list support)
      AC_LANG_PUSH([C++])

      AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
        @%:@include <vector>
        @%:@include <string>
      ]], [[
        std::vector<std::string> v = { "xyzzy", "plugh", "abracadabra" };
      ]])],[
        AC_MSG_RESULT(yes)
        AC_DEFINE(HAVE_CXX11_INITIALIZER_LIST, 1, [Flag indicating whether compiler supports initializer lists])
        have_cxx11_initializer_list=yes
      ],[
        AC_MSG_RESULT(no)
      ])

      AC_LANG_POP([C++])
    fi

    AM_CONDITIONAL(HAVE_CXX11_INITIALIZER_LIST, test x$have_cxx11_initializer_list == xyes)
  ])


AC_DEFUN([LIBMESH_TEST_CXX11_VARIADIC_TEMPLATES],
  [
    have_cxx11_variadic_templates=no

    # Only run the test if enablecxx11==yes
    if (test "x$enablecxx11" = "xyes"); then
      AC_MSG_CHECKING(for C++11 variadic template support)
      AC_LANG_PUSH([C++])

      AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
        // Base case
        template <typename T>
        T sum(T t) { return t; }

        // Compute sum of arbitary number of passed parameters.
        template <typename T, typename ...P>
        T sum(T t, P ...p)
        {
          t += sum(p...);
          return t;
        }
      ]], [[
        sum(1, 2, 3, 4, 5);
      ]])],[
        AC_MSG_RESULT(yes)
        AC_DEFINE(HAVE_CXX11_VARIADIC_TEMPLATES, 1, [Flag indicating whether compiler supports variadic templates])
        have_cxx11_variadic_templates=yes
      ],[
        AC_MSG_RESULT(no)
      ])

      AC_LANG_POP([C++])
    fi

    AM_CONDITIONAL(HAVE_CXX11_VARIADIC_TEMPLATES, test x$have_cxx11_variadic_templates == xyes)
  ])


AC_DEFUN([LIBMESH_TEST_CXX11_THREAD],
  [
    have_cxx11_thread=no

    # Only run the test if enablecxx11==yes
    if (test "x$enablecxx11" = "xyes"); then
      AC_MSG_CHECKING(for C++11 <thread> support)
      AC_LANG_PUSH([C++])

      AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
        @%:@include <thread>
        void my_thread_func() {}
      ]], [[
        std::thread t(my_thread_func);
      ]])],[
        AC_MSG_RESULT(yes)
        AC_DEFINE(HAVE_CXX11_THREAD, 1, [Flag indicating whether compiler supports std::thread])
        have_cxx11_thread=yes
      ],[
        AC_MSG_RESULT(no)
      ])

      AC_LANG_POP([C++])
    fi

    AM_CONDITIONAL(HAVE_CXX11_THREAD, test x$have_cxx11_thread == xyes)
  ])


AC_DEFUN([LIBMESH_TEST_CXX11_TYPE_TRAITS],
  [
    have_cxx11_type_traits=no

    # Only run the test if enablecxx11==yes
    if (test "x$enablecxx11" = "xyes"); then
      AC_MSG_CHECKING(for C++11 <type_traits> support)
      AC_LANG_PUSH([C++])

      AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
        @%:@include <type_traits>
      ]], [[
        bool a = std::is_void<char>::value;
        bool b = std::is_integral<char>::value;
        bool c = std::is_floating_point<char>::value;
      ]])],[
        AC_MSG_RESULT(yes)
        AC_DEFINE(HAVE_CXX11_TYPE_TRAITS, 1, [Flag indicating whether compiler supports std::thread])
        have_cxx11_type_traits=yes
      ],[
        AC_MSG_RESULT(no)
      ])

      AC_LANG_POP([C++])
    fi

    AM_CONDITIONAL(HAVE_CXX11_TYPE_TRAITS, test x$have_cxx11_type_traits == xyes)
  ])


AC_DEFUN([LIBMESH_TEST_CXX11_INVERSE_HYPERBOLIC_FUNCS],
  [
    have_cxx11_inverse_hyperbolic_sine=no
    have_cxx11_inverse_hyperbolic_cosine=no
    have_cxx11_inverse_hyperbolic_tangent=no

    have_cxx11_inverse_hyperbolic_sine_complex=no
    have_cxx11_inverse_hyperbolic_cosine_complex=no
    have_cxx11_inverse_hyperbolic_tangent_complex=no

    # Only run the test if enablecxx11==yes
    if (test "x$enablecxx11" = "xyes"); then
      AC_LANG_PUSH([C++])

      # Test for asinh
      AC_MSG_CHECKING(for C++11 std::asinh support in <cmath>)
      AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
        @%:@include <cmath>
      ]], [[
        double x = std::asinh(1.);
      ]])],[
        AC_MSG_RESULT(yes)
        AC_DEFINE(HAVE_CXX11_INVERSE_HYPERBOLIC_SINE, 1, [Flag indicating whether compiler supports std::asinh])
        have_cxx11_inverse_hyperbolic_sine=yes
      ],[
        AC_MSG_RESULT(no)
      ])

      # Test for acosh
      AC_MSG_CHECKING(for C++11 std::acosh support in <cmath>)
      AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
        @%:@include <cmath>
      ]], [[
        double x = std::acosh(1.);
      ]])],[
        AC_MSG_RESULT(yes)
        AC_DEFINE(HAVE_CXX11_INVERSE_HYPERBOLIC_COSINE, 1, [Flag indicating whether compiler supports std::acosh])
        have_cxx11_inverse_hyperbolic_cosine=yes
      ],[
        AC_MSG_RESULT(no)
      ])

      # Test for atanh
      AC_MSG_CHECKING(for C++11 std::atanh support in <cmath>)
      AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
        @%:@include <cmath>
      ]], [[
        double x = std::atanh(0.);
      ]])],[
        AC_MSG_RESULT(yes)
        AC_DEFINE(HAVE_CXX11_INVERSE_HYPERBOLIC_TANGENT, 1, [Flag indicating whether compiler supports std::atanh])
        have_cxx11_inverse_hyperbolic_tangent=yes
      ],[
        AC_MSG_RESULT(no)
      ])


      # Test for asinh(complex)
      AC_MSG_CHECKING(for C++11 std::asinh(complex) support in <complex>)
      AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
        @%:@include <complex>
      ]], [[
        std::complex<double> z(0, -2);
        std::complex<double> x = std::asinh(z);
      ]])],[
        AC_MSG_RESULT(yes)
        AC_DEFINE(HAVE_CXX11_INVERSE_HYPERBOLIC_SINE_COMPLEX, 1, [Flag indicating whether compiler supports std::asinh])
        have_cxx11_inverse_hyperbolic_sine_complex=yes
      ],[
        AC_MSG_RESULT(no)
      ])

      # Test for acosh(complex)
      AC_MSG_CHECKING(for C++11 std::acosh(complex) support in <complex>)
      AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
        @%:@include <complex>
      ]], [[
        std::complex<double> z(0.5, 0);
        std::complex<double> x = std::acosh(z);
      ]])],[
        AC_MSG_RESULT(yes)
        AC_DEFINE(HAVE_CXX11_INVERSE_HYPERBOLIC_COSINE_COMPLEX, 1, [Flag indicating whether compiler supports std::asinh])
        have_cxx11_inverse_hyperbolic_cosine_complex=yes
      ],[
        AC_MSG_RESULT(no)
      ])

      # Test for atanh(complex)
      AC_MSG_CHECKING(for C++11 std::atanh(complex) support in <complex>)
      AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
        @%:@include <complex>
      ]], [[
        std::complex<double> z(2, 0);
        std::complex<double> x = std::atanh(z);
      ]])],[
        AC_MSG_RESULT(yes)
        AC_DEFINE(HAVE_CXX11_INVERSE_HYPERBOLIC_TANGENT_COMPLEX, 1, [Flag indicating whether compiler supports std::asinh])
        have_cxx11_inverse_hyperbolic_tangent_complex=yes
      ],[
        AC_MSG_RESULT(no)
      ])


      AC_LANG_POP([C++])
    fi

    AM_CONDITIONAL(HAVE_CXX11_INVERSE_HYPERBOLIC_SINE, test x$have_cxx11_inverse_hyperbolic_sine == xyes)
    AM_CONDITIONAL(HAVE_CXX11_INVERSE_HYPERBOLIC_COSINE, test x$have_cxx11_inverse_hyperbolic_cosine == xyes)
    AM_CONDITIONAL(HAVE_CXX11_INVERSE_HYPERBOLIC_TANGENT, test x$have_cxx11_inverse_hyperbolic_tangent == xyes)

    AM_CONDITIONAL(HAVE_CXX11_INVERSE_HYPERBOLIC_SINE_COMPLEX, test x$have_cxx11_inverse_hyperbolic_sine_complex == xyes)
    AM_CONDITIONAL(HAVE_CXX11_INVERSE_HYPERBOLIC_COSINE_COMPLEX, test x$have_cxx11_inverse_hyperbolic_cosine_complex == xyes)
    AM_CONDITIONAL(HAVE_CXX11_INVERSE_HYPERBOLIC_TANGENT_COMPLEX, test x$have_cxx11_inverse_hyperbolic_tangent_complex == xyes)
  ])


AC_DEFUN([LIBMESH_TEST_CXX11_DELETED_FUNCTIONS],
  [
    have_cxx11_deleted_functions=no

    # Only run the test if enablecxx11==yes
    if (test "x$enablecxx11" = "xyes"); then
      AC_MSG_CHECKING(for C++11 deleted functions support)
      AC_LANG_PUSH([C++])

      AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
      class Foo
      {
        Foo(const Foo &) = delete;
      };
      ]], [[
      ]])],[
        AC_MSG_RESULT(yes)
        AC_DEFINE(HAVE_CXX11_DELETED_FUNCTIONS, 1, [Flag indicating whether compiler supports f() = delete;])
        have_cxx11_deleted_functions=yes
      ],[
        AC_MSG_RESULT(no)
      ])

      AC_LANG_POP([C++])
    fi

    AM_CONDITIONAL(HAVE_CXX11_DELETED_FUNCTIONS, test x$have_cxx11_deleted_functions == xyes)
  ])


AC_DEFUN([LIBMESH_TEST_CXX11_FINAL],
  [
    have_cxx11_final=no

    # Only run the test if enablecxx11==yes
    if (test "x$enablecxx11" = "xyes"); then
      AC_MSG_CHECKING(for C++11 'final' keyword support)
      AC_LANG_PUSH([C++])

      AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
      // Test that a function can be declared final.
      struct A
      {
        virtual void foo() final;
      };

      // Test that a struct can be declared final.
      struct B final : A
      {
      };
      ]], [[
      ]])],[
        have_cxx11_final=yes
      ],[
        have_cxx11_final=no
      ])

      # Confirm that you cannot declare a non-virtual function 'final'.
      if (test "x$have_cxx11_final" = "xyes"); then
        AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
        struct A
        {
          // Error: non-virtual function cannot be final
          void bar() final;
        };
        ]], [[
        ]])],[
          # If this code compiles, 'final' is not working correctly.
          have_cxx11_final=no
        ],[
          have_cxx11_final=yes
        ])
      fi

      # Confirm that you cannot override a final function.
      if (test "x$have_cxx11_final" = "xyes"); then
        AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
        struct A
        {
          virtual void foo() final;
        };
        struct B : A
        {
          // Error: foo cannot be overridden as it's final in A
          void foo();
        };
        ]], [[
        ]])],[
          # If this code compiles, 'final' is not working correctly.
          have_cxx11_final=no
        ],[
          have_cxx11_final=yes
        ])
      fi

      # Confirm that you cannot inherit from a 'final' class.
      if (test "x$have_cxx11_final" = "xyes"); then
        AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
        struct A
        {
        };

        // struct B is final
        struct B final : A
        {
        };

        // Error: B is final
        struct C : B
        {
        };
        ]], [[
        ]])],[
          # If this code compiles, 'final' is not working correctly.
          have_cxx11_final=no
        ],[
          have_cxx11_final=yes
        ])
      fi

      # If the flag is still 'yes' after all the tests, set the #define.
      if (test "x$have_cxx11_final" = "xyes"); then
        AC_MSG_RESULT(yes)
        AC_DEFINE(HAVE_CXX11_FINAL, 1, [Flag indicating whether compiler supports f() final;])
      else
        AC_MSG_RESULT(no)
      fi

      AC_LANG_POP([C++])
    fi

    AM_CONDITIONAL(HAVE_CXX11_FINAL, test x$have_cxx11_final == xyes)
  ])


AC_DEFUN([LIBMESH_TEST_CXX11_NULLPTR],
  [
    have_cxx11_nullptr=no

    # Only run the test if enablecxx11==yes
    if (test "x$enablecxx11" = "xyes"); then
      AC_MSG_CHECKING(for C++11 nullptr support)
      AC_LANG_PUSH([C++])

      AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
      @%:@include <cstddef>
      void f(int * pi) {}
      void f(double * pd) {}
      void f(std::nullptr_t nullp) {}
      ]], [[
      // would be ambiguous without void f(nullptr_t)
      f(nullptr);
      ]])],[
        AC_MSG_RESULT(yes)
        AC_DEFINE(HAVE_CXX11_NULLPTR, 1, [Flag indicating whether compiler supports nullptr])
        have_cxx11_nullptr=yes
      ],[
        AC_MSG_RESULT(no)
      ])

      AC_LANG_POP([C++])
    fi

    # Test the nullptr workaround if we don't have the real nullptr
    if (test "x$have_cxx11_nullptr" != "xyes"); then
      AC_MSG_CHECKING(for C++03 compatible nullptr workaround)
      AC_LANG_PUSH([C++])

      AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
      const class my_nullptr_t
      {
      public:
        // convertible to any type of null non-member pointer...
        template<class T>
        inline operator T * () const { return 0; }

        // or any type of null member pointer...
        template<class C, class T>
        inline operator T C::*() const { return 0; }

      private:
        // Can't take address of nullptr
        void operator & () const;
      } my_nullptr = {};

      void f(int) {}
      void f(double *) {}

      ]], [[
      // Test that it works the same way as NULL.
      int * p = my_nullptr;

      // Test that the compiler can disambiguate the call correctly.
      f(my_nullptr);
      ]])],[
        AC_MSG_RESULT(yes)
        AC_DEFINE(HAVE_CXX11_NULLPTR_WORKAROUND, 1,
                  [Flag indicating whether C++03 compatible nullptr workaround works])
        have_cxx11_nullptr_workaround=yes
      ],[
        AC_MSG_RESULT(no)
      ])

      AC_LANG_POP([C++])
    fi

    AM_CONDITIONAL(HAVE_CXX11_NULLPTR, test x$have_cxx11_nullptr == xyes)
    AM_CONDITIONAL(HAVE_CXX11_NULLPTR_WORKAROUND, test x$have_cxx11_nullptr_workaround == xyes)
  ])
